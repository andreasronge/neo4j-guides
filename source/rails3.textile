h2. Rails 3 / Active Model support

endprologue.


Developed by "Nick Sieger":http://github.com/nicksieger/neo4j-rails and extended 
and included in Neo4j.rb by Andreas Ronge and Ben Jackson. You no longer need the neo4j-rails gem.


TIP: Notice that you can use the  @Neo4j::Model@ in a standalone application or Sinatra application. It is also possible to use the @Neo4j::NodeMixin@ or @Neo4j::Node@ in a Rails application instead of the @Neo4j::Model@, see the other guides: "Neo4j Mapping Guide":mapping.html and "Node, Relationships and Properties":basic.html

h3. Usage

The @Neo4j::Model@ implements the Rails ActiveModel interface and a subset of the ActiveRecord API. 

Example:

<ruby>
class IceCream < Neo4j::Model
  property :flavour
  validates_presence_of :flavour
end

IceCream.new.valid?  # => false
IceCream.new(:flavour => "vanilla").valid?  # => true
</ruby>

The @new@ method does not create a new node in the database (unlike  @Neo4j::NodeMixin#new) but instead behaves like ActiveRecord the @new@ method. The node will be saved to the database when the @save@ method is called, just like ActiveRecord.

TIP: The @Neo4j::Model@ includes the "Neo4j::NodeMixin":http://neo4j.rubyforge.org/classes/Neo4j/Mapping/NodeMixin.html but overrides some methods. For more information see the "Neo4j Mapping Guide":mapping.html

h3. Callbacks

The following callbacks are defined: *create* *save* *update* *destroy*
See the "rails documentation":http://api.rubyonrails.org/classes/ActiveRecord/Callbacks.html when they are called.

h3. Transactions

All write operations requires a transaction. Read operations like find,load or read properties does not require transactions.
Some methods: @save@, @destroy@ and @update_attributes@ are automatically wrapped inside a transaction. If you need to write several operations in one operation use @Neo4j::Rails::Transaction@. You will also get better performance using a single transaction instead of several small transactions.

h4. Neo4j::Rails::Transaction

This class can be used as a filter in order to wrap methods in transactions.

Example:
<ruby>
class UsersController < ApplicationController
  around_filter Neo4j::Rails::Transaction, :only => [:create]
</ruby>

The @Neo4j::Rails::Transaction@ class can also be used to access the current running transaction in order
to signal for a rollback.

Example:
<ruby>
class UsersController < ApplicationController
   around_filter Neo4j::Rails::Transaction, :only => [:create, :update]

   def update
     #.. create, update delete some nodes/relationships
     #.. something when wrong, rollback everyting
     Neo4j::Rails::Transaction.current.fail
   end
</ruby>

Notice that you can also use the @Model.transaction@ method to wrap a block of code in a transaction.

Example:
<ruby>
class UsersController < ApplicationController
  def update
    Users.transaction do |tx|
      #.. create, update delete some nodes/relationships
      #.. something when wrong, rollback everyting
      tx.fail
    end
  end
</ruby>


h4. Model.new

The @Neo4j::Model.new@ methods does not require a transaction (unlike the @Neo4j::Node.new@ method)
since it creates a node in memory with no connection to the neo4j database.
This makes it easier to create forms that don't touch the database if validation fails by using
the ActiveRecord-style two-step @Model.new@ + @Model#save@ creation.

h4. Model.save

Saves the node if the validation was successful. It will create a new transaction if neccessarly.
If the saved model that was *not* created by the @Model.new@ method (which means it exist in the database) and
the validation fails then the transaction will be rolled back.
Notice, also nested nodes will be saved (created by has_n, has_one, or outgoing).

h4. Model.update_attributes

Updates the model with the given attributes and saves the model.
Will create a new transaction if neccessarly which can be rollback by the @save@ method if the validation was
not successful.

h4. Model.property

The @Neo4j::Model#property@ method accept additional configuration parameters:, @:default@, @:length@ and @:null@.

Example:
<ruby>
class MyModel < Neo4j::Rails::Model
  # gives title "Mr" unless it is set specifically
  # ensures it is a maximum of 3 chars long
  # ensures it is never saved with a nil value
  property :title, :default => "Mr", :limit => 3, :null => false
end
</ruby>

h3. Nested Attributes

Neo4j.rb supports "accepts_nested_attributes_for":http://api.rubyonrails.org/classes/ActiveRecord/NestedAttributes/ClassMethods.html

The following configuration option are available

*  @:allow_destroy@ If true, destroys any members from the attributes hash with a _destroy key and a value that evaluates to true (eg. 1, ‘1’, true, or ‘true’). This option is off by default.
*  @:reject_if@ Allows you to specify a Proc or a Symbol pointing to a method that checks whether a record should be built for a certain attribute hash. The hash is passed to the supplied Proc or the method and it should return either true or false. When no :reject_if is specified, a record will be built for all attribute hashes that do not have a _destroy value that evaluates to true. Passing :all_blank instead of a Proc will create a proc that will reject a record where all the attributes are blank.

When using the @accepts_nested_attributes_for@ class method you must specify which class the relationship correspond to
by using the @to@ method in @has_one@ or @has_n@.

*Example*

<ruby>
class Member < Neo4j::Model
  has_n(:posts).to(Post)
  has_one(:avatar).to(Avator)

  accepts_nested_attributes_for :avatar, :allow_destroy => true
  accepts_nested_attributes_for :posts, :reject_if => proc { |attributes| attributes[:title].blank? }
end

</ruby>


h3. Validation

All the normal validations work.
Example:
<ruby>
class Person < Neo4j::Model
  index :email
  validates :email, :uniqueness => true
  validates :password, :presence     => true,
                   :confirmation => true,
                   :length       => { :within => 6..40 }
end
</ruby>

In order to get uniquess validation to work you *must* have an exact index on the property, as shown above (*index :email*)

h3. Specifing Relationships (has_n/has_one/has_list)

The @Neo4j::Model@ includes the @Neo4j::NodeMixin@
See "Mapping nodes/relationships to Ruby classes":mapping.html

TIP: Only a limited set of traversal method is available before the node is saved. E.g. methods like @node.outgoing(:work).depth(4).filter{|path| path.length == 2}@ is only possible if node is saved. 

h4. Saving Relationships and Validation 

Unlike using Neo4j::NodeMixin you have to save relationships in order to make them persist (like ActiveRecord). All the nested nodes will be saved when the save method is called and validation will be performed on each nested node.

<ruby>
p1 = Person.new  # or Person.create
p2 = Person.new
p1.friends << p2
p1.save # => true if validation was successful for both p1 and p2
</ruby>

If an validation error occurs the errors will be aggregated on the 'root' object
(in the example above that is p1.errors).

The @outgoing@ method will not return unsaved relationships.

Example:
<ruby>
a.friends << b
a.outgoing(:friends).first # => nil
a.save
a.outgoing(:friends).first # => b
</ruby>


h4. Deleting Relationships

Deleting a relationship does not require a @save@. Instead you have to create an transaction.

Example:

<ruby>
# Find the first relationship between node a and node b
rel = a.rels(:friends).outgoing.to_other(b).first

# Delete this relationship
Neo4j::Transaction.run { rel.del }
a.outgoing(:friends) # does now not include b
</ruby>

Since @del@ was run without  @save@ no validation will be performed.

h4. has_list

The @has_list@ is not wrapped in @Neo4j::Model@. That means that you have to create a transaction 
when you want to modify the list, for more info see "Mapping nodes/relationships to Ruby classes":mapping.html#has_list

h3. Querying

The @find@ and @all@ methods use the model's Lucene index to search for either one or a set of nodes respectively. Make sure to index the properties that you'll query on.

*Example Setup*
<ruby>
class IceCream < Neo4j::Model
  property :flavour
  property :cone

  index :flavour
  index :cone
end
</ruby>

<ruby>
vanilla_sugar = IceCream.create(:flavour => 'vanilla', :cone => 'sugar')
vanilla_waffle = IceCream.create(:flavour => 'vanilla', :cone => 'waffle')
</ruby>

h4. Find

The @find@ method will find the first node that matches its query or @nil@ if one isn't found.

<ruby>
IceCream.find('cone: sugar') #=> vanilla_sugar
IceCream.find('flavour: vanilla') #=> who knows?
IceCream.find(:flavour => 'vanilla') #=> same as above
IceCream.find('flavour: chocolate') #=> nil
</ruby>

The @find@ method will also accept a Neo4j node id which is useful for finding a node in a rails controller.

<ruby>
class IceCreamController < ApplicationController
  
  def show
    @ice_cream = IceCream.find(params[:id])
    # . . .
  end

end
</ruby>


The Neo4j::Model also support Active Record like query syntax:

<ruby>
Model.find(:first, :conditions => { :name => "test" }) # works the same as find("name: \"test\"")
Model.find(:first, :conditions => { :id => 10 }) # works the same as find(10) or find("10")
</ruby>

For more information about indexing and quering, see "Indexing and Quering with Lucene":lucene.html

h4. All

The @all@ method will find a set of nodes or return an empty array if none are found.

<ruby>
IceCream.all #=> [vanilla_sugar, vanilla_waffle]

IceCream.all('flavour: vanilla') #=> [vanilla_sugar, vanilla_waffle]

IceCream.all('flavour: vanilla AND cone: sugar') #=> [vanilla_sugar]

IceCream.all('flavour: chocolate') #=> []
IceCream.all(:flavour => 'chocolate')
IceCream.find(:all, :condition => {:flavour => 'chocolate'}, :sort => {:name => :asc})
</ruby>

Tip: String parameter values with special characters, such as URI's, should be escaped first before setting or querying to not conflict with the Lucene Query Parser Syntax:  + - && || ! ( ) { } ^ " ~ * ? : \ . See "Apache Lucene - Query Parser Syntax":http://lucene.apache.org/java/2_4_0/queryparsersyntax.html

<ruby>
	escaped = URI.escape( "http://neo4j.rubyforge.org/guides", Regexp.new( "[^#{URI::PATTERN::UNRESERVED}]" ))
	Website.find("uri: #{escaped}")
</ruby>
	
or using String#gsub

<ruby>
	escaped = "http://neo4j.rubyforge.org/guides".gsub( /([\+\-\&\|\!\(\)\{\}\[\]\^\"\~\*\?\:\\])/ , "\\\1" )
</ruby>

h4. Fulltext Search

An example of using the lucene full text search index:
<ruby>
class BlogEntry < Neo4j::Rails::Model
  property :text
  index :text, :type => :fulltext
end

e = BlogEntry.create(:text => 'some long text string')

BlogEntry.find('text: long', :type => :fulltext) #=> e
BlogEntry.all('text: long', :type => :fulltext).size #=> 1
</ruby>

Notice that you need to specify the @:fulltext@ configuration property for both declaring the index and searching.

h4. Dynamic Finders

If you declare an index you neo4j.rb will generate finder methods for you.

Example:
<ruby>
class Person
  property :name
  index :name
end

Person.find_by_name 'andreas'  # with underscore of course, not visible

</ruby>


h4. Sorting

Examples:
<ruby>
Person.all('name: Test*').asc(:name).desc(:age)
Person.find(:all, 'name: Test*', :page => 2, :per_page => 2, :sort => {:name => :asc}
Person.first(:conditions => 'name: Test*', :sort => {:name => :asc})
</ruby>

You can add a paginate prefix and it will be paginated (need to specify :page and :per_page parameters).

h4. Range Queries

Does work on String, Fixnum, Float, Date and DateTime, see the "Lucene Queries":lucene.html

h3. API

Many of the familiar API methods from ActiveRecord are duplicated in Neo4j::Model. Neo4j::Model includes 
* ActiveModel::Validations
* ActiveModel::Conversions
* ActiveModel::Callbacks
* ActiveModel::Dirty
* ActiveModel::MassAssignmentSecurity
* ActiveModel::Serializers::Xml
* ActiveRecord::Timestamp (@created_at@ and/or @updated_at@)

Methods:
<ruby>
class Neo4j::Model
  def valid?; end
  def save; end
  def save!; end
  def update_attributes(attributes); end
  def update_attributes!(attributes); end
  def destroy; end
  def attributes=(attrs); end
  def self.all; end
  def self.find(*); end
  def self.create(attributes); end
  def self.create!(attributes); end
  def self.transaction(&lock); end
  def self.accepts_nested_attributes_for(*); end
end
</ruby>

h3. Rails Generators

You can use the standard Rails 3 generators to create your models, controllers, routes, tests and views, by passing 'neo4j' as the ORM for generators to use:

<pre>> rails generate scaffold User name:string born:date --orm=neo4j</pre>

You can also set up your application configuration to use neo4j as the default ORM for generating templates.  Simply add the following to your application's Rails configuration.  This example also favours RSpec and specifies that fixtures are not to be created:

<pre>config.generators do |g|
  g.orm             :neo4j
  g.test_framework  :rspec, :fixture => false
end</pre>

Then you can simply call generators as normal without having to specify the ORM:

<pre> rails generate model Admin --parent User</pre>

To undo what was just generated:

<pre> rails destroy model Admin</pre>

To create a model with timestamps:

<pre>rails generate scaffold Post title:string --timestamps</pre>

h4. Rails Neo4j Project Template

Example of creating an Neo4j Application from scratch, type

<pre>
gem install rails
rails new myapp -m http://andreasronge.github.com/rails3.rb
cd myapp
bundle
rails generate scaffold User name:string email:string
rails s
</pre>
open a webbrowser: http://localhost:3000/users

h3. Installation and Configuration

If you don't want to use the Neo4j Project template above you can do it yourself.

h4. Replace ActiveRecord with Neo4j

Edit the config/application.rb
comment the line require 'rails/all' and add
<ruby>
require "action_controller/railtie"
require "action_mailer/railtie"
require "active_resource/railtie"
require "rails/test_unit/railtie"
require 'neo4j'
</ruby>

h4. Include Dependency to Neo4j

Add the following line to your Gemfile
<code>
gem 'neo4j', '1.0.0'
</code>
and remove all sql gems. Install the gems specified in your Gemfile @bundle install@

h4. Configuration

You can set the location of the database in the @config/application.rb@ file.
Example:

<ruby>
config.neo4j.storage_path = "#{config.root}/db/neo4j-#{Rails.env}"
config.neo4j.timestamps = false  # disable automatic timestamps on updated_at and created_at properties
</ruby>


h4. Deployment

* Installing JRuby - see "RVM":http://rvm.beginrescueend.com/
* "Tomcat/Trinidad":https://github.com/calavera/trinidad
* "Glassfish App Server":http://www.scottlowe.eu/deploying-rails-3-with-jruby-15-daemonized-gl

Trinidad needs the Java jar files in the lib folder.
There is a script for doing this:
<pre>
neo4j-jars -local
</pre>
Just type @neo4j-jars@ for help

If you forget to add those jar files to your rails project you may get the following error message:
<pre>
No index provider 'lucene' found
</pre>

h3. Backup

See "Configuration & Backup":configuration.html

Add the following line in your config/application.rb file:

<pre>
config.neo4j.online_backup_enabled = true
</pre>

Then add the correct jar files to the lib folder:

<pre>
neo4j-jars -backup
</pre>

To perform the backup
<ruby>
require 'neo4j'
Neo4j.load_online_backup
Neo4j::OnlineBackup('localhost').incremental('/var/backup')
</ruby>

h3. HA Cluster


Add the following line in your config/application.rb file:

<pre>
config.neo4j['ha.db']=true
</pre>

Then add the correct jar files to the lib folder:

<pre>
cd YOUR_RAILS_ROOT
neo4j-jars -ha
</pre>

h3. Integration with other Rails Gems

h4. devise

See the "devise-neo4j gem":http://github.com/benjackson/devise-neo4j and
"devise_example":http://github.com/andreasronge/devise_example

h4. will_paginate

First you need to include the will_paginate gem, edit your Gemfile
<pre>
  gem "will_paginate", "~> 3.0.pre2"
</pre>
and add in the config/application.rb file
<pre>
  require 'will_paginate'
</pre>

In your controller paginate the traversal or search result.
Example
<ruby>
 def index
   # Example 1, with lucene query does support sorting !
   @users = User.paginate(:all, 'name: P*', :total_entries => 100,:page => params[:page], :per_page => 3)
   # Example 2, with traversal, does not support sorting
   @users = User.all.paginate(:page => params[:page], :per_page => 3)
 end    
</ruby>

In the view.
<erb>
<%= will_paginate(@users) %>
</erb>

h3. FAQ

h4. Why do I get @ERROR IOError: Connection reset by peer@ ?

It's a JRuby bug which is solved in JRuby version >= 1.6

h4. I get "No index provider 'lucene' found"

See deployment above.

h4. org.neo4j.kernel.impl.core.ReadOnlyDbException

You get this exception if there is already an neo4j db instance running.
Only one write instance of the database is possible. If there is already a write instance running then a read only db will be created.
Did you run the rails console before you did the first request to rails ?

h4. Why can't I update nested models: node.nested << x; node.nested.save ?

Let say you have the following class:

<ruby>
class Person < Neo4j::Rails::Model
  has_one(:nested)
end

node = Person.create
node.nested = Person.create
node.save
</ruby>

Then you can't update the @node.nested@ 
<ruby>
node.nested[:some_property] = 'some value'
node.nested.nested << other_node
node.nested.save
</ruby>

Instead you must use a temporary variable, like this:

<ruby>
tmp = node.nested
tmp[:some_property] = 'some value'
tmp.nested << other_node
tmp.save
</ruby>

The reason is that the @node.nested@ creates a new instance of a
wrapped node.

However, the following will work:
<ruby>
n = Person.create
n.nested = Person.create
n.nested[:name] = 'foo'
n.save

n.nested[:name] # => 'foo'
</ruby>

You do not need a temporary variable in this case since the relationship is not 
persisted yet.
