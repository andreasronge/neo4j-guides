h2. Rails 3 / Active Model support

endprologue.


Developed by "Nick Sieger":http://github.com/nicksieger/neo4j-rails and extended 
and included in Neo4j.rb by Andreas Ronge and Ben Jackson. You no longer need the neo4j-rails gem.

h3. Usage

The @Neo4j::Model@ implements the Rails ActiveModel interface. That means that you can use
the normal validation and other methods that you are used to in ActiveRecord.

Example:

<ruby>
class IceCream < Neo4j::Model
  property :flavour
  validates_presence_of :flavour
end

IceCream.new.valid?  # => false
IceCream.new(:flavour => "vanilla").valid?  # => true
</ruby>

TIP: The @Neo4j::Model@ includes the "Neo4j::NodeMixin":http://neo4j.rubyforge.org/classes/Neo4j/Mapping/NodeMixin.html For more information see the "Neo4j Mapping Guide":mapping.html

h3. Callbacks

The following callbacks are defined: *create* *save* *update* *destroy*
See the "rails documentation":http://api.rubyonrails.org/classes/ActiveRecord/Callbacks.html when they are called.

h3. Transactions

All write operations requires a transaction. Read operations like find,load or read properties does not require transactions.
Some methods like @save@ and @destroy@, @update_attributes@ are automatically wrapped inside a transaction. If you need to write several operations in one operation use @Neo4j::Rails::Transaction@. You will also get better performance using a single transaction instead of several small transactions.

h4. Neo4j::Rails::Transaction

This class can be used as a filter in order to wrap methods in transactions.

Example:
<ruby>
class UsersController < ApplicationController
  around_filter Neo4j::Rails::Transaction, :only => [:create]
</ruby>

The @Neo4j::Rails::Transaction@ class can also be used to access the current running transaction in order
to signal for a rollback.

Example:
<ruby>
class UsersController < ApplicationController
   around_filter Neo4j::Rails::Transaction, :only => [:create, :update]

   def update
     #.. create, update delete some nodes/relationships
     #.. something when wrong, rollback everyting
     Neo4j::Rails::Transaction.current.fail
   end
</ruby>

Notice that you can also use the @Model.transaction@ method to wrap a block of code in a transaction.

Example:
<ruby>
class UsersController < ApplicationController
  def update
    Users.transaction do |tx|
      #.. create, update delete some nodes/relationships
      #.. something when wrong, rollback everyting
      tx.fail
    end
  end
</ruby>


h4. Model.new

The @Neo4j::Model.new@ methods does not require a transaction (unlike the @Neo4j::Node.new@ method)
since it creates a node in memory with no connection to the neo4j database.
This makes it easier to create forms that don't touch the database if validation fails by using
the ActiveRecord-style two-step @Model.new@ + @Model#save@ creation.

h4. Model.save

Saves the node if the validation was successful. It will create a new transaction if neccessarly.
If the saved model that was *not* created by the @Model.new@ method (which means it exist in the database) and
the validation fails then the transaction will be rolled back.

h4. Model.update_attributes

Updates the model with the given attributes and saves the model.
Will create a new transaction if neccessarly which can be rollback by the @save@ method if the validation was
not successful.

h3. Nested Attributes

Neo4j.rb supports "accepts_nested_attributes_for":http://api.rubyonrails.org/classes/ActiveRecord/NestedAttributes/ClassMethods.html

The following configuration option are available

*  @:allow_destroy@ If true, destroys any members from the attributes hash with a _destroy key and a value that evaluates to true (eg. 1, ‘1’, true, or ‘true’). This option is off by default.
*  @:reject_if@ Allows you to specify a Proc or a Symbol pointing to a method that checks whether a record should be built for a certain attribute hash. The hash is passed to the supplied Proc or the method and it should return either true or false. When no :reject_if is specified, a record will be built for all attribute hashes that do not have a _destroy value that evaluates to true. Passing :all_blank instead of a Proc will create a proc that will reject a record where all the attributes are blank.

When using the @accepts_nested_attributes_for@ class method you must specify which class the relationship correspond to
by using the @to@ method in @has_one@ or @has_n@.

*Example*

<ruby>
class Member < Neo4j::Model
  has_n(:posts).to(Post)
  has_one(:avatar).to(Avator)

  accepts_nested_attributes_for :avatar, :allow_destroy => true
  accepts_nested_attributes_for :posts, :reject_if => proc { |attributes| attributes[:title].blank? }
end

</ruby>


h3. Validation

All the normal validations work.
Example:
<ruby>
class Person < Neo4j::Model
  index :email
  validates :email, :uniqueness => true
  validates :password, :presence     => true,
                   :confirmation => true,
                   :length       => { :within => 6..40 }
end
</ruby>

In order to get uniquess validation to work you *must* have an exact index on the property, as shown above (*index :email*)

h3. API

Many of the familiar API methods from ActiveRecord are duplicated in Neo4j::Model. Neo4j::Model includes 
* ActiveModel::Validations
* ActiveModel::Conversions
* ActiveModel::Callbacks
* ActiveModel::Dirty
* ActiveModel::MassAssignmentSecurity
* ActiveModel::Serializers::Xml
* ActiveRecord::Timestamp (@created_at@ and/or @updated_at@)

Methods:
<ruby>
class Neo4j::Model
  def valid?; end
  def save; end
  def save!; end
  def update_attributes(attributes); end
  def update_attributes!(attributes); end
  def destroy; end
  def attributes=(attrs); end
  def self.all; end
  def self.find(*); end
  def self.create(attributes); end
  def self.create!(attributes); end
  def self.transaction(&lock); end
  def self.accepts_nested_attributes_for(*); end
end
</ruby>

h3. Rails Generators

You can use the standard Rails 3 generators to create your models, controllers, routes, tests and views, by passing 'neo4j' as the ORM for generators to use:

<pre>> rails generate scaffold User name:string email:string --orm=neo4j</pre>

You can also set up your application configuration to use neo4j as the default ORM for generating templates.  Simply add the following to your application's Rails configuration.  This example also favours RSpec and specifies that fixtures are not to be created:

<pre>config.generators do |g|
  g.orm             :neo4j
  g.test_framework  :rspec, :fixture => false
end</pre>

Then you can simply call generators as normal without having to specify the ORM:

<pre> rails generate model Admin --parent User</pre>

To undo what was just generated:

<pre> rails destroy model Admin</pre>

h4. Rails Neo4j Project Template

Example of creating an Neo4j Application from scratch, type

<pre>
gem install rails
rails new myapp -m http://andreasronge.github.com/rails3.rb
cd myapp
bundle
rails generate scaffold User name:string email:string
rails s
</pre>
open a webbrowser: http://localhost:3000/users

h3. Installation and Configuration

If you don't want to use the Neo4j Project template above you can do it yourself.

h4. Replace ActiveRecord with Neo4j

Edit the config/application.rb
comment the line require 'rails/all' and add
<ruby>
require "action_controller/railtie"
require "action_mailer/railtie"
require "active_resource/railtie"
require "rails/test_unit/railtie"
require 'neo4j'
</ruby>

h4. Include Dependency to Neo4j

Add the following line to your Gemfile
<code>
gem 'neo4j', '1.0.0.beta.19'
</code>
and remove all sql gems.

Install the gems specified in your Gemfile @bundle install@

h4. Configuration

You can set the location of the database in the @config/application.rb@ file.
Example:

<ruby>
config.neo4j.storage_path = "#{config.root}/db/neo4j-#{Rails.env}"
config.neo4j.timestamps = false  # disable automatic timestamps on updated_at and created_at properties
</ruby>


h4. Deployment

* Installing JRuby - see "RVM":http://rvm.beginrescueend.com/
* "Tomcat/Trinidad":https://github.com/calavera/trinidad
* "Glassfish App Server":http://www.scottlowe.eu/deploying-rails-3-with-jruby-15-daemonized-gl

h3. FAQ

h4. Why do I get @ERROR IOError: Connection reset by peer@ ?

Not sure, but it does not occur when you use Tomcat/Trinidad

h4. Why can't I open the rails console while the application is running ?

Because only one singel instance of neo4j is allowed to run at the same time
(unless one use a REST client or maybe a readonly instance of the Neo4j server, todo ...)


