h2. Graph Algorithms

* Neo4j comes included with some graph algorithms. Since Neo4j.rb simply wraps algorithms implemented in Java they should have good performence.
* All the @Neo4j::Algo@ methods comes in two versions: @some_algorithm_paths@ and @some_algorithm_path@. The first one returns all paths found, the second one returns only the first path found.
* The @Neo4j::Algo@ methods behaves like the @Neo4j::Node.outgoing@ traversal methods. That means you can combine @outgoing@, @expand@ and @incoming@ method
to specify which relationship should be traversed using the algorithm.
endprologue.
* Implemented in HEAD of upcomming 1.0.0.beta.25

h3. All Paths

The @Neo4j::Algo.all_paths@ and @Neo4j::Algo.all_path@ methods returns an algorithm which can find all available paths between two nodes. 
These returned paths can contain loops (i.e. a node can occur more than once in any returned path).

Example: nodes in the first path with relationship friends found between node_a and node_b:
<ruby>
Neo4j::Algo.all_paths(node_a, node_b).outgoing(:friends).first.nodes
# same as (notice paths and path !)
Neo4j::Algo.all_path(node_a, node_b).outgoing(:friends).nodes

</ruby>

Example: nodes in the first path with relationship friends and depth 1 found between node_a and node_b:
<ruby>
Neo4j::Algo.all_paths(node_a,node_b).outgoing(:friends).depth(1).first

</ruby>

Example: return the length of the first path of relationship :friends found between node_a and node_b:
<ruby>
  Neo4j::Algo.all_paths(node_a,node_b).outgoing(:friends).first.length

</ruby>

Example: return the relationships of the first path of any relationship found between node_a and node_b:
<ruby>
  # singular: all_path - return the first path found
  Neo4j::Algo.all_path(node_a,node_b).rels

</ruby>


h3. All Simple Paths


The @Neo4j::Algo#all_simple_paths@ and @Neo4j::Algo#all_simple_path@ methods returns an algorithm which can find all simple paths between two nodes.
These returned paths cannot contain loops (i.e. a node cannot occur more than once in any returned path).


h3. Shortest Paths

The @Neo4j::Algo.shortest_paths@ and @Neo4j::Algo.shortest_path@ methods find all shortest paths (that is paths with as short Path.length() as possible) between two nodes. These returned paths cannot contain loops (i.e. a node cannot occur more than once in any returned path).

Example, using the expand method just for fun
<ruby>
Neo4j::Algo.shortest_path(node_a,node_b).expand{|node| node._rels(:outgoing, :friends)}
# same as
Neo4j::Algo.shortest_path(node_a,node_b).outgoing(:friends)
</ruby>


Example, shortest path with two relationships:
<ruby>
 Neo4j::Algo.shortest_path(node_a,node_b).outgoing(:friends).outgoing(:knows)
</ruby>

h3. Dijkstra Paths

The @Neo4j::Algo.dijkstra_paths@ and @Neo4j::Algo.dijkstra_path@ methods returns the Dijkstra algorithm to find the cheapest path between two nodes. The definition of "cheap" is the lowest possible cost to get from the start node to the end node, where the cost is returned from cost_evaluator.
These returned paths cannot contain loops (i.e. a node cannot occur more than once in any returned path).
See "here":http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm for more information.
    
Example:
<ruby>
Neo4j::Algo.dijkstra_path(@x,@y).cost_evaluator{|rel,*| rel[:weight]}
</ruby>
