h2. Migrations




* By using migrations you can keep the code and the database in sync. There are two types of migrations : none lazy and lazy.
In a none lazy migration the database is upgraded/downgraded all at once, while in lazy migrations the node/relationship is only upgraded/downgraded when the node or relationship is loaded.

* A common usecase for migration is adding a lucene index on an existing database.

* Implemented in upcomming 1.0.0.beta.27 (or git head)

endprologue.

h3. Global Migrations

Here is an example of a use case for this feature.
Let say that we already have a database with nodes that have one property 'name'.
Now we want to split that property into two properties: 'surname' and 'given_name'.
We want to upgrade the database when it starts so we don't use the lazy migration feature.
The neo4j database starts at version 0 by default.

<ruby>
Neo4j.migrate 1, "split name" do
  up 
   # find all people and change
   Person.all.each {|p|
     self.surname = self[:name].split[0]
     self.given_name = self[:name].split[1]
     self[:name] = nil
   end

    Neo4j.ref_node.each { do stuff }
  end


  down do
   Person.all.each {|p|
     self.name = "#{self[:surname]} {self[:given_name]}"
     self[:surname] = nil
     self[:given_name] = nil
   end
    Neo4j.ref_node.each { do stuff }
 end
end
</ruby>

If the code above has been loaded before the neo database starts it will automatically upgrade to version 1 (running all the migrations to the higest migration available).
You can force the neo4j to go to a specific version by using @Neo4j#migrate!@ method.

h3. MigrationMixin

It's also possible to have one version for each node class.
In the example above there is only one version for the whole database.

Example

<ruby>
class Person
  include Neo4j::NodeMixin # does also work for Neo4j::Rails::Model
  include Neo4j::MigrationMixin 

  rule(:all)
end


Person.migration 1, :split_name do
  up do
    all.each_raw do |node|
      node[:given_name] = node[:name].split[0]
      node[:surname]    = node[:name].split[1]
      node[:name]       = nil
    end
  end

  down do
    all.each_raw do |node|
      node[:name]       = "#{node[:given_name]} #{node[:surname]}"
      node[:surename]   = nil
      node[:given_name] = nil
   end
end
</ruby>

In the example above we are using the @all@ method which are generated by using the rule @rule(:all)@.
The @up@ and @down@ method are evaulated in the context of the class (Person).
The @all.each_raw@ method will return all node instances of type Person as Java nodes (node not wrapped in your Person class)


h3. Lazy Migration

The example above can also be run as lazy migration. i.e. perform the upgrade/downgrade when the node is loaded instead of all at once.
The following example demonstrates this feature:

<ruby>
class Person
  include Neo4j::NodeMixin # does also work for Neo4j::Rails::Model
  include Neo4j::LazyMigrationMixin
end
  
Person.migration 1, :split_name do
  # Split name into two properties
  up do
    self[:name]
    self[:given_name] = self[:name].split[0]
    self[:surname]    = self[:name].split[1]
    self[:name]      = nil
  end

  down do
    self.name       = "#{self[:given_name]} #{self[:surname]}"
    self.surename   = nil
    self.given_name = nil
  end
end

</ruby>

Each node has a version property which is changed when an migration is executed.
The @up@ and @down@ blocks are evaluated in the context of the java node being loaded.
